/**
 * @brief 计算两个二维坐标点之间的欧式距离
 * 
 * 基于欧式距离公式 sqrt((x2-x1)² + (y2-y1)²) 实现，
 * 支持double类型坐标，返回高精度距离值。
 * 
 * @param x1 第一个点的x坐标
 * @param y1 第一个点的y坐标
 * @param x2 第二个点的x坐标
 * @param y2 第二个点的y坐标
 * @return double 两点之间的欧式距离（单位：与输入坐标一致）
 * @note 若输入坐标为负数，仍能正确计算（距离非负）
 * @warning 输入坐标值过大可能导致精度损失
 * @example 
 *   double dist = calculateDistance(0, 0, 3, 4); // 返回5.0
 */


<launch>
    <!-- 全局控制参数 -->
    <arg name="launch_all" default="true" doc="同时启动两个节点"/>
    <arg name="launch_rfid" default="$(arg launch_all)" doc="是否启动RFID节点"/>
    <arg name="launch_mags" default="$(arg launch_all)" doc="是否启动磁传感器节点"/>
    
    <!-- 节点共享参数 -->
    <arg name="port_rfid" default="/dev/ttyUSB0" doc="RFID设备串口"/>
    <arg name="port_mags" default="/dev/ttyUSB1" doc="磁传感器串口"/>
    
    <!-- 包含RFID节点的启动配置 -->
    <group if="$(arg launch_rfid)">
        <include file="$(find memsplus_sensor_ros)/launch/mprid1356.launch">
            <arg name="port" value="$(arg port_rfid)"/>
            <arg name="mapping_mode" value="$(arg mapping_mode)"/>
            <arg name="initial_id" value="$(arg initial_id)"/>
            <arg name="distance_thr" value="$(arg distance_thr)"/>
            <arg name="signal_thr" value="$(arg signal_thr)"/>
        </include>
    </group>
    
    <!-- 包含磁传感器节点的启动配置 -->
    <group if="$(arg launch_mags)">
        <include file="$(find memsplus_sensor_ros)/launch/mpmgs201.launch">
            <arg name="port" value="$(arg port_mags)"/>
        </include>
    </group>
</launch>




#include <ros/ros.h>
#include <serial/serial.h>
#include <std_msgs/String.h>
#include "mpmgs20x/MagneticNavigation.h"

serial::Serial ser;

// 校验和计算（不含帧头0x4D）
uint8_t calculateChecksum(const uint8_t* data, size_t len) {
    uint8_t checksum = 0;
    for (size_t i = 0; i < len; ++i) {
        checksum ^= data[i];
    }
    return checksum;
}

int main(int argc, char**argv) {
    ros::init(argc, argv, "mpmgs20x_rs232_node");
    ros::NodeHandle nh;
    ros::Publisher nav_pub = nh.advertise<mpmgs20x::MagneticNavigation>("magnetic_navigation", 100);

    // 串口参数配置
    std::string port;
    int baudrate;
    nh.param<std::string>("port", port, "/dev/ttyUSB0");
    nh.param<int>("baudrate", baudrate, 115200);

    try {
        ser.setPort(port);
        ser.setBaudrate(baudrate);
        serial::Timeout to = serial::Timeout::simpleTimeout(100);
        ser.setTimeout(to);
        ser.open();
    } catch (serial::IOException& e) {
        ROS_ERROR_STREAM("无法打开串口: " << e.what());
        return -1;
    }

    if (ser.isOpen()) {
        ROS_INFO_STREAM("串口已打开: " << port << " @ " << baudrate);
    } else {
        return -1;
    }

    ros::Rate loop_rate(200); // 高于最大输出速率
    uint8_t buffer[1024];
    size_t buffer_len = 0;

    while (ros::ok()) {
        if (ser.available()) {
            size_t n = ser.read(&buffer[buffer_len], sizeof(buffer) - buffer_len);
            buffer_len += n;

            // 解析帧数据（寻找0x4D开头的完整帧）
            for (size_t i = 0; i < buffer_len; ++i) {
                if (buffer[i] == 0x4D && (buffer_len - i) >= 7) { // 最小帧长：1（头）+1+1+1+1+2+1=8字节
                    uint8_t* frame = &buffer[i];
                    uint8_t field_num = frame[1];
                    uint8_t checksum = frame[7]; // 第8字节为校验和

                    // 校验和验证
                    if (calculateChecksum(&frame[1], 6) == checksum) {
                        mpmgs20x::MagneticNavigation msg;
                        msg.field_num = field_num;
                        msg.field1_offset = static_cast<int8_t>(frame[2]);
                        msg.field2_offset = static_cast<int8_t>(frame[3]);
                        msg.field3_offset = static_cast<int8_t>(frame[4]);
                        msg.active_bits = (frame[5] << 8) | frame[6]; // 拼接高低位

                        nav_pub.publish(msg);
                        ROS_DEBUG("发布导航数据: 段数=%d, 偏移1=%dmm, 点位=0x%04X",
                                 field_num, msg.field1_offset, msg.active_bits);
                    }

                    // 移除已解析的帧
                    buffer_len -= (i + 8);
                    memmove(buffer, &buffer[i + 8], buffer_len);
                    i = 0; // 重新检查缓冲区
                }
            }

            // 处理不完整帧（保留末尾不完整部分）
            if (buffer_len >= sizeof(buffer)) {
                ROS_WARN("缓冲区溢出，清空数据");
                buffer_len = 0;
            }
        }

        ros::spinOnce();
        loop_rate.sleep();
    }

    ser.close();
    return 0;
}