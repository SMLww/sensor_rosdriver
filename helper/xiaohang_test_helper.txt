/* communication protocol RS-232*/
size_t n = serial_.read(&buffer[buffer_len], sizeof(buffer) - buffer_len);
buffer_len += n;

size_t i = 0;  // 改用while循环避免for循环中的i重置问题
while (i < buffer_len) {
    // 查找帧头0x4D，确保剩余数据足够组成一帧
    if (buffer[i] == 0x4D && (buffer_len - i) >= 8) {  // 明确要求8字节
        uint8_t* frame = &buffer[i];
        uint8_t field_num = frame[1];
        uint8_t checksum = frame[7];
        
        // 验证校验和
        if (calculateChecksum(&frame[1], 6) == checksum) {
            geometry_msgs::PoseStamped mag_offset;
            mag_offset.header.stamp = ros::Time::now();
            
            // 关键改进：假设frame[2]是有符号整数（原代码按无符号处理会导致负数解析错误）
            int8_t raw_offset = static_cast<int8_t>(frame[2]);
            mag_offset.pose.position.y = static_cast<double>(raw_offset) / 1000.0;
            
            mag_offset_pub.publish(mag_offset);
            ROS_INFO("Y axis offset: %lf (raw: 0x%02X)", 
                     mag_offset.pose.position.y, frame[2]);
        } else {
            ROS_WARN("Checksum mismatch: calculated %02X, received %02X",
                     calculateChecksum(&frame[1], 6), checksum);
        }
        
        // 移除已处理的帧
        buffer_len -= (i + 8);
        memmove(buffer, &buffer[i + 8], buffer_len);
        i = 0;  // 重新检查缓冲区
    } else {
        i++;
    }
}

// 处理缓冲区溢出
if (buffer_len >= sizeof(buffer)) {
    ROS_WARN("Buffer overflow, clearing %zu bytes", buffer_len);
    buffer_len = 0;
}

ros::spinOnce();
rate.sleep();





















/* communication protocol RS-232*/
size_t n = serial_.read(&buffer[buffer_len], sizeof(buffer) - buffer_len);
buffer_len += n;

size_t i = 0;  // 改用while循环避免for循环中的i重置问题
while (i < buffer_len) {
    // 查找帧头0x4D，确保剩余数据足够组成一帧（8字节）
    if (buffer[i] == 0x4D && (buffer_len - i) >= 8) {
        uint8_t* frame = &buffer[i];
        uint8_t field_num = frame[1];  // 这是需要判断的字段
        uint8_t checksum = frame[7];

        // 新增条件：只有当field_num为1时才处理数据
        if (field_num == 1) {
            // 验证校验和
            if (calculateChecksum(&frame[1], 6) == checksum) {
                geometry_msgs::PoseStamped mag_offset;
                mag_offset.header.stamp = ros::Time::now();

                // 修正：使用有符号整数解析，避免负数处理错误
                int8_t raw_offset = static_cast<int8_t>(frame[2]);
                mag_offset.pose.position.y = static_cast<double>(raw_offset) / 1000.0;

                mag_offset_pub.publish(mag_offset);
                ROS_INFO("有效Y轴偏移: %lf (原始值: 0x%02X)", 
                         mag_offset.pose.position.y, frame[2]);
            } else {
                ROS_WARN("校验和不匹配: 计算值%02X, 接收值%02X",
                         calculateChecksum(&frame[1], 6), checksum);
            }
        } else {
            ROS_DEBUG("忽略无效field_num: %d (非1)", field_num);
        }

        // 移除已处理的帧（无论是否有效都跳过这一帧）
        buffer_len -= (i + 8);
        memmove(buffer, &buffer[i + 8], buffer_len);
        i = 0;  // 重新检查缓冲区
    } else {
        i++;
    }
}

// 处理缓冲区溢出
if (buffer_len >= sizeof(buffer)) {
    ROS_WARN("缓冲区溢出，清空 %zu 字节数据", buffer_len);
    buffer_len = 0;
}

ros::spinOnce();
rate.sleep();










